'use strict';
import { autoCorrection } from './autoCorrection';
export const fieldTypes = {
    NUMERIC: 'NUMERIC',
    ALPHABETIC: 'ALPHABETIC',
    ALPHANUMERIC: 'ALPHANUMERIC',
};
export default function createFieldParser(fieldOptions) {
    checkType(fieldOptions, 'label', 'string');
    if (fieldOptions.field !== null) {
        checkType(fieldOptions, 'field', 'string');
    }
    checkType(fieldOptions, 'line', 'number');
    checkType(fieldOptions, 'start', 'number');
    checkType(fieldOptions, 'end', 'number');
    checkType(fieldOptions, 'parser', 'function');
    const ranges = [
        {
            line: fieldOptions.line,
            start: fieldOptions.start,
            end: fieldOptions.end,
        },
    ];
    if (Array.isArray(fieldOptions.related)) {
        for (const related of fieldOptions.related) {
            checkType(related, 'line', 'number');
            checkType(related, 'start', 'number');
            checkType(related, 'end', 'number');
            ranges.push(related);
        }
    }
    const parser = (lines, autocorrect = []) => {
        const source = getText(lines, fieldOptions);
        const related = fieldOptions.related || [];
        const textRelated = related.map((r) => getText(lines, r));
        const result = {
            label: fieldOptions.label,
            field: fieldOptions.field,
            value: null,
            valid: false,
            ranges: ranges.map((range) => ({
                line: range.line,
                start: range.start,
                end: range.end,
                raw: getText(lines, range),
            })),
            line: 0,
            start: 0,
            end: 0,
            autocorrect,
        };
        const range = result.ranges[0];
        result.line = range.line;
        result.start = range.start;
        result.end = range.end;
        try {
            const parsed = fieldOptions.parser(source, ...textRelated);
            result.value = typeof parsed === 'object' ? parsed.value : parsed;
            result.valid = true;
            if (typeof parsed === 'object') {
                result.start = range.start + parsed.start;
                result.end = range.start + parsed.end;
            }
        }
        catch (e) {
            result.error = e.message;
        }
        return result;
    };
    const autocorrector = (lines) => {
        let corrected = lines;
        let source = getText(lines, fieldOptions);
        let autocorrect = [];
        const type = fieldOptions.type || fieldTypes.ALPHANUMERIC;
        if (type !== fieldTypes.ALPHANUMERIC) {
            const result = autoCorrection(source, fieldOptions);
            source = result.correctedLine;
            autocorrect = result.autocorrect;
        }
        corrected = changeText(lines, fieldOptions, source);
        return { correctedLines: corrected, autocorrect };
    };
    return { parser, autocorrector };
}
function getText(lines, options) {
    const line = lines[options.line];
    return line.substring(options.start, options.end);
}
function changeText(lines, options, text) {
    const line = lines[options.line];
    const newText = line.substring(0, options.start) + text + line.substring(options.end);
    lines[options.line] = newText;
    return lines;
}
function checkType(options, name, type) {
    if (typeof options[name] !== type) {
        throw new TypeError(`${name} must be a ${type}`);
    }
}
//# sourceMappingURL=createFieldParser.js.map