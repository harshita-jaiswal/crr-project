"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BytesInput = exports.StreamInput = exports.Base64Input = exports.PathInput = exports.Input = exports.INPUT_TYPE_PATH = exports.INPUT_TYPE_BYTES = exports.INPUT_TYPE_BASE64 = exports.INPUT_TYPE_STREAM = void 0;
const fs_1 = require("fs");
const path = __importStar(require("path"));
const fileType = __importStar(require("file-type"));
const handler_1 = require("./errors/handler");
const pdf_lib_1 = require("pdf-lib");
const node_buffer_1 = require("node:buffer");
const logger_1 = require("./logger");
exports.INPUT_TYPE_STREAM = "stream";
exports.INPUT_TYPE_BASE64 = "base64";
exports.INPUT_TYPE_BYTES = "bytes";
exports.INPUT_TYPE_PATH = "path";
const MIMETYPES = new Map([
    [".pdf", "application/pdf"],
    [".heic", "image/heic"],
    [".jpg", "image/jpeg"],
    [".jpeg", "image/jpeg"],
    [".png", "image/png"],
    [".tif", "image/tiff"],
    [".tiff", "image/tiff"],
    [".webp", "image/webp"],
]);
const ALLOWED_INPUT_TYPES = [
    exports.INPUT_TYPE_STREAM,
    exports.INPUT_TYPE_BASE64,
    exports.INPUT_TYPE_BYTES,
    exports.INPUT_TYPE_PATH,
];
class Input {
    /**
     * @param {String} inputType - the type of input used in file ("base64", "path", "dummy").
     *                             NB: dummy is only used for tests purposes
     * @param {Boolean} cutPages
     * NB: Because of async calls, init() should be called after creating the object
     */
    constructor({ inputType }) {
        this.MAX_DOC_PAGES = 3;
        this.filename = "";
        this.mimeType = "";
        this.fileObject = node_buffer_1.Buffer.alloc(0);
        // Check if inputType is valid
        if (!ALLOWED_INPUT_TYPES.includes(inputType)) {
            const allowed = Array.from(MIMETYPES.keys()).join(", ");
            handler_1.errorHandler.throw(new Error(`Invalid input type, must be one of ${allowed}.`));
        }
        this.inputType = inputType;
        logger_1.logger.debug(`Loading file from: ${inputType}`);
    }
    async init() {
        throw new Error("not Implemented");
    }
    isPdf() {
        return this.mimeType === "application/pdf";
    }
    async checkMimetype() {
        let mimeType;
        const fileExt = path.extname(this.filename);
        if (fileExt) {
            mimeType = MIMETYPES.get(fileExt.toLowerCase()) || "";
        }
        else {
            const guess = await fileType.fromBuffer(this.fileObject);
            if (guess !== undefined) {
                mimeType = guess.mime;
            }
            else {
                throw "Could not determine the MIME type of the file";
            }
        }
        if (!mimeType) {
            const allowed = Array.from(MIMETYPES.keys()).join(", ");
            const err = new Error(`Invalid file type, must be one of ${allowed}.`);
            handler_1.errorHandler.throw(err);
        }
        logger_1.logger.debug(`File is of type: ${mimeType}`);
        return mimeType;
    }
    async countPages() {
        const pdfDocument = await pdf_lib_1.PDFDocument.load(this.fileObject, {
            ignoreEncryption: true,
        });
        return pdfDocument.getPageCount();
    }
    /** Merge PDF pages */
    async cutPdf() {
        const currentPdf = await pdf_lib_1.PDFDocument.load(this.fileObject, {
            ignoreEncryption: true,
        });
        const pdfLength = currentPdf.getPageCount();
        if (pdfLength <= this.MAX_DOC_PAGES) {
            return;
        }
        const newPdf = await pdf_lib_1.PDFDocument.create();
        const pagesNumbers = [0, pdfLength - 2, pdfLength - 1].slice(0, this.MAX_DOC_PAGES);
        logger_1.logger.debug(`Cutting PDF, keeping pages: ${pagesNumbers}`);
        const pages = await newPdf.copyPages(currentPdf, pagesNumbers);
        pages.forEach((page) => newPdf.addPage(page));
        const data = await newPdf.save();
        this.fileObject = node_buffer_1.Buffer.from(data);
    }
}
exports.Input = Input;
class PathInput extends Input {
    constructor({ inputPath }) {
        super({
            inputType: exports.INPUT_TYPE_PATH,
        });
        this.inputPath = inputPath;
        this.filename = path.basename(this.inputPath);
    }
    async init() {
        logger_1.logger.debug(`Loading from: ${this.inputPath}`);
        this.fileObject = node_buffer_1.Buffer.from(await fs_1.promises.readFile(this.inputPath));
        this.mimeType = await this.checkMimetype();
    }
}
exports.PathInput = PathInput;
class Base64Input extends Input {
    constructor({ inputString, filename }) {
        super({
            inputType: exports.INPUT_TYPE_BASE64,
        });
        this.filename = filename;
        this.inputString = inputString;
    }
    async init() {
        this.fileObject = node_buffer_1.Buffer.from(this.inputString, "base64");
        this.mimeType = await this.checkMimetype();
        // clear out the string
        this.inputString = "";
    }
}
exports.Base64Input = Base64Input;
class StreamInput extends Input {
    constructor({ inputStream, filename }) {
        super({
            inputType: exports.INPUT_TYPE_STREAM,
        });
        this.filename = filename;
        this.inputStream = inputStream;
    }
    async init() {
        this.fileObject = await this.stream2buffer(this.inputStream);
        this.mimeType = await this.checkMimetype();
    }
    async stream2buffer(stream) {
        return new Promise((resolve, reject) => {
            const _buf = Array();
            stream.on("data", (chunk) => _buf.push(chunk));
            stream.on("end", () => resolve(node_buffer_1.Buffer.concat(_buf)));
            stream.on("error", (err) => reject(`Error converting stream - ${err}`));
        });
    }
}
exports.StreamInput = StreamInput;
class BytesInput extends Input {
    constructor({ inputBytes, filename }) {
        super({
            inputType: exports.INPUT_TYPE_BYTES,
        });
        this.filename = filename;
        this.inputBytes = inputBytes;
    }
    async init() {
        this.fileObject = node_buffer_1.Buffer.from(this.inputBytes, "hex");
        this.mimeType = await this.checkMimetype();
        // clear out the string
        this.inputBytes = "";
    }
}
exports.BytesInput = BytesInput;
