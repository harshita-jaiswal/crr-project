"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const inputs_1 = require("./inputs");
const api_1 = require("./api");
const documents_1 = require("./documents");
const documentConfig_1 = require("./documents/documentConfig");
const handler_1 = require("./errors/handler");
const logger_1 = require("./logger");
const constants_1 = require("./constants");
class DocumentClient {
    constructor(inputDoc, docConfigs) {
        this.inputDoc = inputDoc;
        this.docConfigs = docConfigs;
    }
    async parse(responseClass, params = {
        docType: "",
        username: "",
        cutPages: true,
        fullText: false,
        cropper: false,
    }) {
        // seems like there should be a better way of doing this
        const fullText = params?.fullText !== undefined ? params.fullText : false;
        const cropper = params?.cropper !== undefined ? params.cropper : false;
        const cutPages = params?.cutPages !== undefined ? params.cutPages : true;
        const docType = params.docType === undefined || params.docType === ""
            ? this.getDocType(responseClass.name)
            : params.docType;
        const found = [];
        this.docConfigs.forEach((config, configKey) => {
            if (configKey[1] === docType) {
                found.push(configKey);
            }
        });
        if (found.length === 0) {
            throw `Document type not configured: '${docType}'`;
        }
        let configKey = [];
        if (found.length === 1) {
            configKey = found[0];
        }
        else if (params.username) {
            configKey = [params.username, docType];
        }
        const docConfig = this.docConfigs.get(configKey);
        if (docConfig === undefined) {
            // TODO: raise error printing all usernames
            throw `Couldn't find the config '${configKey}'`;
        }
        return await docConfig.predict(responseClass, {
            inputDoc: this.inputDoc,
            includeWords: fullText,
            cutPages: cutPages,
            cropper: cropper,
        });
    }
    getDocType(responseClass) {
        return constants_1.ProductConfigs.getByResponseClassName(responseClass).docType;
    }
}
/**
 * Mindee Client
 */
class Client {
    /**
     * @param options
     */
    constructor(options) {
        const throwOnError = options?.throwOnError === undefined ? true : options.throwOnError;
        const debug = options?.debug === undefined ? false : options.debug;
        this.apiKey = options?.apiKey === undefined ? "" : options.apiKey;
        this.docConfigs = new Map();
        handler_1.errorHandler.throwOnError = throwOnError;
        logger_1.logger.level =
            debug ?? process.env.MINDEE_DEBUG
                ? logger_1.LOG_LEVELS["debug"]
                : logger_1.LOG_LEVELS["warn"];
        logger_1.logger.debug("Client initialized");
        this.addStandardEndpoints();
    }
    // TODO: init only those endpoints we actually need.
    addStandardEndpoints() {
        this.docConfigs.set([api_1.STANDARD_API_OWNER, documents_1.DOC_TYPE_INVOICE], new documentConfig_1.InvoiceConfig(this.apiKey));
        this.docConfigs.set([api_1.STANDARD_API_OWNER, documents_1.DOC_TYPE_RECEIPT], new documentConfig_1.ReceiptConfig(this.apiKey));
        this.docConfigs.set([api_1.STANDARD_API_OWNER, documents_1.DOC_TYPE_FINANCIAL], new documentConfig_1.FinancialDocConfig(this.apiKey));
        this.docConfigs.set([api_1.STANDARD_API_OWNER, documents_1.DOC_TYPE_PASSPORT], new documentConfig_1.PassportConfig(this.apiKey));
        this.docConfigs.set([api_1.STANDARD_API_OWNER, documents_1.DOC_TYPE_CROPPER], new documentConfig_1.CropperConfig(this.apiKey));
    }
    addEndpoint({ accountName, documentType, version = "1", }) {
        this.docConfigs.set([accountName, documentType], new documentConfig_1.CustomDocConfig({
            accountName: accountName,
            documentType: documentType,
            version: version,
            apiKey: this.apiKey,
        }));
        return this;
    }
    docFromPath(inputPath) {
        const doc = new inputs_1.PathInput({
            inputPath: inputPath,
        });
        return new DocumentClient(doc, this.docConfigs);
    }
    docFromBase64(inputString, filename) {
        const doc = new inputs_1.Base64Input({
            inputString: inputString,
            filename: filename,
        });
        return new DocumentClient(doc, this.docConfigs);
    }
    docFromStream(inputStream, filename) {
        const doc = new inputs_1.StreamInput({
            inputStream: inputStream,
            filename: filename,
        });
        return new DocumentClient(doc, this.docConfigs);
    }
    docFromBytes(inputBytes, filename) {
        const doc = new inputs_1.BytesInput({
            inputBytes: inputBytes,
            filename: filename,
        });
        return new DocumentClient(doc, this.docConfigs);
    }
}
exports.Client = Client;
